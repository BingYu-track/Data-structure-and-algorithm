package lessons.week12.bitwise;

import java.util.Arrays;

/**
 * @version 1.0
 * @Description: 位运算总结
 * @author: bingyu
 * @date: 2023/7/12
 */
public class Bitwise {


    /*
     在计算机中，所有数据底层都是用二进制表示的，操作二进制位的方法叫做位运算，
     基础的位运算包含: 与、或、异或、取反、左移、右移。
     除此之外，还有两个常用操作: 十进制转二进制，二进制转十进制

     1、与(&): 判断某位是否为1、设置某位为0、判断奇偶
     2、或(|): 设置某位为1
     3、异或(^): 反转位，a^a=0 ，两位不同就是1，相同是0 (寻找出现一次的数字)，(注意: 1个数字和0异或得到的结果就是该数字本身)
                异或运算满足交换律，A^B=C C^B=A C^B=A 。异或符号和 "加、减、乘、除"这些符号一样，如果知道结果和其中的一个值就
                可以确定另外一个值了，而&(与)和|(或)就不能完全确定了。比如a&1=1或者a&1=0，我们可以确定a的值，但如果a&0=0，我们就无法确定a究竟是0还是1了

     4、取反(~): 按位取反
     5、左移(<<): 乘以2
     6、右移(>>): 除以2 (二分查找)
     7、十进制 --> 二进制
     8、二进制 --> 十进制

     byte类型占8位； 1个字节 8位
     short类型: 2个字节  16位
     int 类型: 4 个字节  32位
     long 类型: 8个字节  64位
     float 类型: 4个字节 32位
     double 类型: 8个字节 64位
     boolean类型: 1个字节 8位
     char 类型: 2个字节 16位

     十进制数左移后会变成原来的10 倍、100 倍、1000 倍……
     同样，二进制数左移后就会变成原来的2 倍、4 倍、8 倍……
     反之，二进制数右移后则会变成原来的1/2、1/4、1/8…….
   但是要注意的是右移要分两种情况：
    TODO  (1).算数右移(>>): 如果数值是用补数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地实现1/2、1/4、1/8 等的数值运算
          (2).逻辑右移(>>>): 无论数值是正数还是负数，右移后空出来的最高位都是补0

     TODO: 重点--负数在计算机中的表示以及运算
      1.二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。 符号位是0时表示正数 ，符号位是1时表示负数。
          那么－1 用8位二进制数来表示的话是什么样的呢？可能很多人会认为“1 的二进制数是00000001，因此-1 就是10000001”，
          但这个答案是错的，正确答案是11111111。计算机在做减法运算时，实际上内部是在做加法运算。用加法运算来实现减法运算，是不是很新奇呢？
          为此，在表示负数时就需要使用“二进制的补数”。[ 补数就是用正数来表示负数。为了获得补数，我们需要将二进制数的各数位的数值全部取反，
          然后再将结果加1 ] 。例如，用8 位二进制数表示－ 1 时，只需求得1，也就是00000001 的补数即可。具体来说，就是将各数位的0取反成1，
          1取反成0，然后再将取反的结果加1，最后就转化成了11111111;
      2.例如1-1，也就是1+(- 1) 这一运算，我们都知道答案应该是0。首先，让我们将-1表示成10000001（错误的表示方法）来运算，看看结
        果如何。00000001＋10000001 = 10000010， 很明显结果不是0;如果结果是0，那么所有的数位都应该是0才对。接下来，让我们把
         -1表示成11111111（正确的表示方法）来进行运算。 00000001＋11111111 确实为0（= 00000000）。这个运算中出现了最高位溢出的情况，不过，
         正如之前所介绍的那样，对于溢出的位，计算机会直接忽略掉。在8 位的范围内进行计算时，100000000 这个9位二进制数就会被认为是00000000


     十六进制转二进制:
      十六进制的一个数对应二进制四个数字，四对一转化,具体可以对照下面的表格，因为十六进制是满16进1，另外4位2进制刚好是0~16的取值范围，因此
      十六进制的1位相当于二进制的4位

      十六进制                      二进制
         ------------------------------
         0                         0000
         ------------------------------
         1                         0001
         ------------------------------
         2                         0010
         ------------------------------
         3                         0011
         ------------------------------
         4                         0100
         ------------------------------
         5                         0101
         ------------------------------
         6                         0110
         ------------------------------
         7                         0111
         ------------------------------
         8                         1000
         ------------------------------
         9                         1001
         ------------------------------
         A                         1010
         ------------------------------
         B                         1011
         ------------------------------
         C                         1100
         ------------------------------
         D                         1101
         ------------------------------
         E                         1110
         ------------------------------
         F                         1111
         ------------------------------
     二进制转十六进制
    */


    public static void main(String[] args) {
        int a = -2147483648;
        Bitwise bw = new Bitwise();
        int[] res = bw.decimalToBinary2(a);
        System.out.println(Arrays.toString(res));
        int num = bw.binaryToDecimal2(res);
        System.out.println(num);
        //[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0]
    }

    /*
     十进制数转二进制数组
     TODO： 由于java的int类型是32位，因此需要创建长度为32的数组，然后我们将十进制数的每个位和1进行与操作，这样的
      目的是为了得到该十进制在二进制下每位的数，例如: 5的二进制是101，101 & 001得到1； 101 & 010得到0；101 & 100得到1，这样
      我们就能从10进制数得到10进制在二进制中每位的数字了！
    */

    //方法一: 目标数不断右移，使其二进制每位数能和1进行"与"运算，从而得到目标数每位的二进制数(不推荐)
    //TODO：注意这个方法不能用来处理"负数"，负数是用补数的形式，在这里k会不断的--，最终变成负数导致bits[k]数组越界
    public int[] decimalToBinary(int num) {
        int[] bits = new int[32];
        int k = bits.length - 1;
        while (num!=0) {
            bits[k] = num & 1;
            k--; //移动到num在二进制的上一位
            num = num >> 1; //num进行右移达到的效果是一样的，使上一位的数字移动到和1同样的位置，从而方便进行"与"操作
        }
        return bits;
    }

    //方法二: 将1不断进行左移，使其能和目标数的每个位进行"与"运算得到目标数每位的二进制数

    //TODO 错误代码：
    public int[] decimalToBinary2ERROR(int num) {
        int[] bits = new int[32];
        int cons = 1; //用来作为工具数字的1,构造从2^0 ~ 2^31
        for (int i = bits.length - 1;i>=0;i--) {
            //注意这里与计算后得到的不是某位的数，而是好几位的数，因此不能直接赋值到bits数组里，例如110 & 010 = 10 得到的k是2，而不是第2位的1
            int k = num & cons;
            bits[i] = k;
            cons <<= 1; //将1左移
        }
        return bits;
    }

    //TODO 正确代码: 推荐该方法，让数字1不断的右移再进行与运算
    public int[] decimalToBinary2(int num) {
        int[] bits = new int[32];
        int cons = 1; //用来作为工具数字的1,构造从2^0 ~ 2^31
        for (int i = 31;i>=0;i--) {
            /*
            TODO：
             由于110 & 010 = 10 不能直接得到1，我们可以这样理解，因为是目标元素每一位和同位的1做比较，
             例如10 & 10 = 10  110 & 100    1010 & 1000，可以发现与的都是当前位为1的数字，其它都会成为0，这样的话只要
             与计算不为0，就说明目标数字的当前二进制位为1，也就是对应下面这个if代码
            */
            if((num & cons) != 0) {
                bits[i] = 1;
            }
            cons <<= 1;
        }
        return bits;
    }


    /*
     二进制数组转为十进制数:
        TODO： 就是使用二进制转十进制的公式，例如--110对应的十进制：1*2^2 + 1*2^1 + 0*2^0 = 6
    */

    //方法1: 正数和负数均可使用
    public int binaryToDecimal(int[] bits) {
        int b = 0;
        int mask = 1; //从2^0 到 2^31
        for (int i = bits.length - 1;i >=0;i--) {
            b += bits[i] * mask; //就是用的公式:  110 对应的十进制：1*2^2 + 1*2^1 + 0*2^0 = 6
            mask <<= 1; //1不断向左移动一位，即乘以2
        }
        return b;
    }

    //方法2: 从高位开始，不断加低位，正，负数均可使用
    public int binaryToDecimal2(int[] bits) {
        int c = 0;
        int length = bits.length;
        for (int i = 0;i<length;i++) { //11110010  这里数组开始部分是高位，尾部是低位
            //TODO： 每次乘以2，再加上后面的。然后整体结构再乘以2，再加上后面的，这样得到的就是对应的十进制数，
            // 可以这样理解，将一个字符串"576"转为数字576，那么取高位5*10+7得到57，后面再用57*10+6得到数字576，
            // 同样下面的也是这个思想，2进制的2就相当于上面的10，用"当前位数*进制数+后面一位数"不断执行累加就能得到整个数了
            c <<= 1; //左移1位，以242的二进制数11110010为例，从高位开始这里会一直为0，直到遇到二进制数的第一个1
            c += bits[i]; //(2+1) * 2
        }
        return c;
    }


}
