package lessons.week12.bitwise.pratice.pratice4;

/**
 * @version 1.0 面试题 05.07. 配对交换
 * @Description: 配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。
 *
 * 示例1:
 * 输入：num = 2（或者0b10）
 * 输出 1 (或者 0b01)
 *
 * 示例2:
 * 输入：num = 3
 * 输出：3
 *
 *  1101 -> 1110
 *  8+4+1=13 -> 8+4+2=14
 * 提示:
 * num的范围在[0, 2^30 - 1]之间，不会发生整数溢出。
 *
 * @author: bingyu
 * @date: 2023/8/2
 */
public class ExchangeBits {

    public static void main(String[] args) {
        ExchangeBits eb = new ExchangeBits();
        int res = eb.exchangeBitsZg(2);
        System.out.println(res);
    }



    /*
      如何实现二进制位进行交换? TODO 核心思路就是先提取出奇数位和偶数位所在的数字，然后进行运算组合！
     思路:  可以这样想，位数交换，要么是当前位置和1交换，要么是和0交换，如果交换数字不同，那么会进行改变，如果交换的数字相同两者和原来一样，相当于是做
     了一个或运算
     思路: 1.先分别取出偶数位和奇数位，取出偶数位的意思就是，偶数位的数字保留，奇数位的数字全部变为0；对取出奇数位也是同理
            以101110为例，取出偶数位后就成了101010，取出奇数位是000100
          2.分别取出奇数位和偶数位后，然后位左移奇数位，右移偶数位，这样就达到了正确的数位位置了。
          3.然后再把奇数位和偶数位做或运算，这样由于偶数位数字的奇数位是0，奇数位数字的偶数位也都是0，这样无论是奇数位数字和偶数位数字都是在和0进行或运算
            这样的话就可以将奇数位的数字和偶数位的数字都存放在一起了！

         int -> 32位
        奇数位全1 -> 0101.... 表示为 0x55555555
        偶数位全1 -> 1010.... 表示为 0xaaaaaaaa
        0x11 = 10001  (16进制的十位数，相当于10000)
        0X111 = 100010001

        问: 如何理解十六进制的1位对应二进制的4位？
        0x5 = 101
        0x15 = 10101 十六进制的十位数1相当于10进制的16，也就是二进制的2^4，即10000
        0x25 = 100101   十六进制的十位数2相当于10进制的32，也就是二进制的2^5,即100000
    同理..........................
    TODO: 这样我们可以发现十六进制数每进1位，对应的二进制数就要进4位，因此十六进制的1位对应二进制的4位更加方便，除非16进制不进位，一直处于个数，
     二进制数就不一定是4位的，0,1,2 二进制就对应 0、1、10...

     执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
     内存消耗：38 MB, 在所有 Java 提交中击败了82.10%的用户
    */
    public int exchangeBits(int num) {
        int a = 0x55555555;//一个十六进制位等于4个二进制位，因此用8个十六进制位就能占满32位，为了提取奇数，因此需要奇数位全为1，即需要每4位是0101，对应十六进制就是5
        int b = 0xaaaaaaaa; //同理，十进制的A就是10，对应二进制的4位是1010
        //1.提取奇数位
        int oddBit = num & a;
        //2.提取偶数位
        int evenBit = num & b;
        oddBit <<= 1; //奇数位右移
        evenBit >>= 1; //偶数位左移
        int res = oddBit | evenBit; //最后进行或运算
        return res;
    }

    /*
     争哥解法: 让目标数字依次和每个奇数位数字以及偶数位数字进行与运算并拆出，然后颠倒顺序进行或运算累加！

     */
    public int exchangeBitsZg(int num) {
        int ret = 0;
        //num - [0, 2^30 - 1]
        //所以位数是30个位
        for(int i = 0; i <= 30; i += 2){
            //TODO (1).1左移i位，再和num与运算，相当于num不断和奇数位的数字进行与运算(因为i是一次走两步，因此1<<i每次都是在奇数位的)
            int a1 = (num & (1 << i));
            int b1 = (num & (1 << (i+1))); //同上，num不断和偶数位的数字进行与运算

            //如果奇数位是1,则加上交换位;如果是0则加上也没⽤。 为何是0的话，就不能交换了？因为并不影响，只要前面还有1，中间的0就会被包含在内
            //将每一位都剥离出来，然后颠倒顺序进行累加
            if(a1 != 0) {  //
                ret |= (1 << (i+1)); //1 << (i+1)就是(1 << i)对应的交换位
                //ret累积2^(i+1)
            }
            if(b1 != 0) { //如果偶数位是1
                ret |= (1 << i); //ret累积2^i
            }
        }
        return ret;
    }




    /*重复练习
     提取奇数位和偶数位；如果要提取奇数，那么必须是....0101这样交替的 0x55555555
     同理提取偶数位必须是......1010这样交替的 0xAAAAAAAA
    */
    public int exchangeBits2(int num) {
        int a = num & 0x55555555; //提取奇数，保存奇数位的数字，偶数位数字全变成0
        int b = num & 0xAAAAAAAA; //提取偶数，保存偶数位的数字，奇数位数字全变成0
        a <<= 1; //左移，使奇数位数字移动到偶数位
        b >>= 1; //右移，使偶数位数字移动到奇数位
        return a | b; //然后进行或运算，保留两部分的数值
    }


}
