package lessons.week6.pratice.btree;

/**
 * @version 1.0
 * @Description: 总结
 * @author: bingyu
 * @date: 2022/8/23
 */
public class Summary {

    public static void main(String[] args) {

    }

    /*
      二叉树题型套路
      二叉树是是重点中的重点，面试常考，必须拿下

      二叉树的8类题型:
      Part1
      题型1: 二叉树前中后序遍历
            TODO 使用递归方法即可，迭代法比较难(注意二叉树的前、中后序遍历就是DFS，深度优先搜索)
                  1. 前序遍历(先根遍历)——访问根结点的操作发生在遍历其左右子树之前（根->左子树->右子树）。
                  2. 中序遍历(中根遍历)——访问根结点的操作发生在遍历其左右子树之中（左子树->根->右子树)。
                  3. 后序遍历(后根遍历)——访问根结点的操作发生在遍历其左右子树之后（左子树->右子树->根）。

      题型2: 二叉树按层遍历
            TODO 最直接的解法是使用二维数组；优雅的解法是使用队列(二叉树的按层遍历就是BFS，广度优先搜索)
      题型3: 二叉树上的递归
            TODO 树和子树结构类似，一般使用递归解决，这类题目范围比较广
      题型4: 二叉查找树
            TODO 借助二叉查找树中序遍历结果为有序序列的特点来解题

      Part2
      题型5: LCA最近公共祖先
            TODO 求LCA转换为求左右子树的p/q结点，因为只有LCA左右子树两个都有；
      题型6: 二叉树转单、双、循环链表
            TODO 使用虚拟头节点作为起始节点，然后一个tail随时指向末尾，遍历过程中tail不断指向当前root节点;
                 复用二叉树的left，right指针，作为单链表的next
      题型7: 按照遍历结果反向构造二叉树
            TODO 该题型的重点是寻找到左子树的前中后序遍历结果，以及右子树的前中后序遍历结果
                 前序遍历结果: 3 9 20 15 7
                 中序遍历结果: 9 3 15 20 7
                 根据前序遍历结果我们知道树的根节点是3，然后根据中序遍历结果知道，3的左边的数是左子树，右边的都是右子树,
                 解题时类比归并、快排，用下标标记左子树和右子树的范围(前序和后序相对复杂，具体看pratice8)

       TODO 关于前序、后序构建二叉树的情况，需要拿出来单独说一下
        解题前置知识--     前序数组排列特点:根、左子树所有元素、右子树所有元素
                        后序数组排列特点:左子树所有元素、右子树所有元素、根
                  一般情况下前序、后序是无法唯一确定一棵二叉树的，只有 前序，中序 或者 中序，后序 是可以唯一可以确定一棵树的，
                  下面是前序、后序的一个案例
                  前序：1、2、5、3、4
                  后序：5、4、3、2、1
                  1.对于前序中的每一个根节点，在后序中去找这个根节点（1）和根节点后面一个结点（2）的位置。
                  2.在后序中，如果 1 号位置在 2 号位置之间的右边，并且二者之间有元素，说明之间的元素都属于1号的右子树，2号位置
                    及前面的元素都属于1号的左子树，如果递归下去都是这样，就是唯一的；如果 1 号和 2 号位置之间没有元素，这时
                    就没有办法判断它是属于左子树属于右子树(此时2以及其它所有元素要么是1的左子树，要么是1的右子树)，二叉树也就不唯一了。
                下面对于 2 个具体的例子给出图示：

                先给出不唯一的情况：
                1                       1                         1
                 \                     /                           \
                  2                   2                             2
                 / \                 / \                           / \
                5   3               5   3                         5   3
                   /                   /                               \
                  4                   4                                 4
                eg1                  eg2                            eg3
            下面按上述思路大致走一下流程:
            1) 1在后序为index5;1在前序的后面是2，在后序是index4也是紧挨着的。
            2) 1和2之间在前序和后序里，它们之间没有元素;由于1是根节点，那么2可能是1的左子树，也可能是右子树(如果左子树没有，后序就是直接打印的右子树根节点)
               这样就可以肯定树不唯一了。
            3) 2在前序中后面紧挨着的是5，而5在后序中是第一个元素，2和5中间夹着4、3这2个元素;单看前序5可能是2的左子树，也可能是2的右子树，
               但是在后序中，中间夹了2个元素，如果5是右子树的话，那么5就应该紧挨着2的前面，因此现在只有4,3确定就是2的右子树，5是2的左子树，
               没有其他的情况了，这样即为局部子树唯一。
            4).........

            再给出唯一的情况：
            前序：1、2、3、4、6、7、5
            后序：2、6、7、4、5、3、1
                                     1
                                   /   \
                                  2     3
                                       / \
                                      4   5
                                     / \
                                    6   7

            1. 1在后序中是最后一个，没啥问题，都是root节点，前序中1后面紧挨着的是2。
            2. 在后序中1前面紧挨着的是3,2在后序的第一个元素，1和2夹着很多元素，所以2不可能是1的右子树，只可能是1的左子树；
               中间6,7,4,5,3都是1的右子树。
            3. 在后序中，2的位置在3的左边，这说明3并不在以2为根节点的树，而是属于另外一棵子树，因为如果3是在2根节点的树上，
               那么在后序中，3应该出现在2的前面

           结论: 可以看到这种情况还有一个特点：每个结点的出度是 0 或者 2。
           （可以这么理解：如果节点只有一个儿子结点的话，在递归判断的时候无法知道是否是左儿子还是右儿子；但是如果有两个或者没有的话，是可以判断的。）

      题型8: 二叉树上的最强路径和
            TODO 使用递归遍历的过程中进行处理，当压栈调用递归函数时使用sum变量记录到当前节点的路径和；即每次压栈时加当前节点值，
                 弹栈，返回时减去当前节点值，当递归遇到null时说明走完了一条完整的路径，此时将对应的sum存储到数组即可
     */

    /*基础知识
       前序遍历，就是按'根左右'的顺序遍历 时间复杂度-O(n) 因为递归树中，每个节点的递和归的操作都是常量的
       中序遍历，就是按'左根右'的顺序遍历
       后序遍历，就是按'左右根'的顺序遍历

       满二叉树:最后一层叶子节点是满的，没有空洞
       完全二叉树: 中间没有空洞，叶子节点全在最后一层，但叶子节点不是满的

        一、二叉树的存储
           1.基于指针的存储(大部分情况都是用的这种方式)


           2.基于数组的存储(完全二叉树、堆、线段树)
             基于数组存储的只适合完全二叉树，因为完全二叉树不会浪费数组空间，而非完全二叉树有很多空洞，会导致数组极大浪费
             具体存储方法: 根节点存储在下标为1的位置，节点之间的父子关系，通过数组下标计算得到：如果节点x的下标是i
             ---下标为2*i的位置存储左子节点
             ---下标为2*i+1的位置存储右子节点
             ---下标为i/2的位置存储就是它的父节点

          3.节点个数为n的二叉树，高度是多少?
            TODO: 首先要明确二叉树"高度"和"深度"的定义，因为关于高度和深度，许多书籍与教材的说法大不一致，
                    (1) --------------1层(高度为4，深度为1)
                  /    \
                (2)    (3) ---------------2层(高度为3，深度为2)
              /    \     \
            (4)    (5)   (6) -------------3层(高度为2，深度为3)
                   /
                 (7)  -------------------4层(高度为1，深度为4)
            看网上有2种说法:
              (1).二叉树的深度为根节点到最远叶子节点的最长路径上的节点数，按照这个逻辑，上面的二叉树深度就是4(深度是当前节点~~根节点)
                  二叉树的高度从该节点到叶子节点的最长路径上的节点数，按照该逻辑二叉树高度也是4(高度是当前节点~~叶子节点)

              (2).树中的某节点的深度是它到根节点的路径上的边的条数，按照该逻辑，上面的二叉树深度是3。(深度是当前节点~~根节点)
                 树中某节点的高度是指从该节点到叶子节点的最长简单路径边的条数，按照该逻辑，上面的二叉树高度用是3。(高度是当前节点~~叶子节点)
                 树的高度等于所有节点的最大深度(即树的深度)。
              TODO:以上两种定义都可以，因此在题目中如果有涉及树的深度或者高度，需要问清楚这个高度和深度的定义


            TODO: 这里以树高度的第(1)种定义为基础，因为leetcode是以节点数来定义的
            n为二叉树的节点个数
            a.最大高度: 为n，即没有分叉相当于链表(注: 如果以边数定义，这里应该是n-1)
            b.最小高度: 约log2n，对应最后一层完全二叉树到满二叉树的情况:  每一层节点数=2^(h-1)
                完全二叉树: n = 1+2+4+....+2^(H-2) +1 = (1-2^(H-1))/(1-2) + 1 = 2^(H-1) -> log2n = H-1 -> H = log2n + 1
                满二叉树:  n = 1+2+4+....+2^(H-1) = (1-2^H)/(1-2) = 2^(H)-1 -> n+1 = 2^H -> H = log2(n+1)
                完全二叉树的高度: [log2n + 1 , log2(n+1) )
                满二叉树的高度: log2(n+1)
            因此上面的解答是:树的高度介于log2n ~ n之间

         4.一颗树的高度是h，那包含多少个节点呢?
           a.最少节点:h (即形成了一个链表)
           b.最多节点:2^(h-1)   (即满二叉树)
           节点个数介于h ~ 2^(h-1)

        二叉树的遍历总结:
        前中后序遍历都可以看作树上的深度优先遍历，也属于回溯算法。
        根据处理节点的时机的不同，分为三类:前中后序


       二、二叉查找树
          二叉查找树是一种特殊的二叉树，支持快速地查找、插入、删除数据。
          对于二叉查找树中的任意一个节点，
         a.其左子树中每个节点的值，都小于这个节点的值。
         b.其右子树中每个节点的值，都大于这个节点的值。
    */

    //二叉查找树递归实现
    public class Node {
        private Node root = null;
        private int data;
        private Node left;
        private Node right;

        public Node(int data) {
            this.data = data;
        }


        //1.二叉查找树查找元素的实现
        public Node find_r(Node root,int data) {
            if (root == null) return null;
            if (root.data == data) {
                return root;
            }
            if (data < root.data) {
                return find_r(root.left,data);
            }else { //data > root.data
                return find_r(root.right,data);
            }
        }

        //2.1 二叉查找树插入操作(递归实现) 思路: 比root大且root右子节点为null，则插入，否则将其右子节点作为root继续比较计算；如果比root小同理
        public void insert_r(Node root,int data) {
            if (data > root.data) { //比root大
                if (root.right == null) {   //root右子节点为null就插入
                    root.right = new Node(data);
                }else { //不为null，将右子节点作为root重新比较计算
                    insert_r(root.right,data);
                }
            }else {//比root小
                if (root.left == null) { //root左子节点为null就插入
                    root.left = new Node(data);
                }else { //不为null，将左子节点作为root重新比较计算
                    insert_r(root.left,data);
                }
            }
        }

        //2.2 二叉查找树插入操作(非递归实现)
        public void insert(int data) {
            if (root == null) {
                root = new Node(data);
                return;
            }
            Node p = root;
            while (p != null) {
                if (data > p.data) {
                    if (p.right == null) {
                        p.right = new Node(data);
                        return;
                    }
                    p = p.right;
                }else { //data < p.data
                    if (p.left == null) {
                        p.left = new Node(data);
                        return;
                    }
                    p = p.left;
                }
            }
        }

        /*
        3.二叉查找树删除操作(复杂)
        针对待删除节点的子节点个数的不同，我们分三种情况。
        a.第一种情况: 要删除的节点没有子节点。只需要直接将父节点中指向要删除节点的指针置为null即可

        b.第二种情况: 要删除的节点只有一个子节点。只需要更新父节点中指向要删除节点的指针，让它重新指向要删除节点的子节点即可。

        c.第三种情况: 要删除的节点有两个子节点。需要找到这个节点的右子树中的最小节点(即在右子树里不断往左寻找)，把它替换到要
           删除的节点上(或左子树的最大节点，总之就是最接近这个被删除节点值的节点)。然后再删除掉这个"最小节点"，因为"最小节点"
           肯定没有左子节点，只可能是有一个右子节点，或者，没有子节点所以我们此时可以应用上面两条规则来删除这个最小节点。
        */

        public void delete(int data) {
            Node p = root;
            Node pp = null; //用来记录p的父节点
            while (p!=null && p.data != data) { //TODO： 1.查找要删除的节点及其父节点，直到p为null或者找到要删除的节点为止
                pp = p;
                if (data > p.data) { //如果要删除的大于当前p节点，则向右子节点寻找
                    p = p.right;
                }else {
                    p = p.left; //小于当前p节点，则向左子节点寻找
                }
            }
            if (p == null) return;; //说明没有找到要删除的节点，直接返回

            //TODO: 2.要删除的节点有两个子节点,这里我们查找待删除节点的右子树的最小节点，即不断向左查找
            if (p.left != null && p.right != null) {
                Node minP = p.right;
                Node minPP = p; //minPP表示minP的父节点
                while (minP.left != null) {
                    minPP = minP;
                    minP = minP.left;
                }
                p.data = minP.data; //将左子树最小节点的数据替换掉待删除的节点，然后删除p节点即可
                p = minP; //TODO 下面就变成了删除minP这个节点，这里之所以要赋值p，还有赋值pp是为了复用下面的代码来删除该节点
                pp = minPP;
            }

            //TODO: 3.执行到这里，说明要删除的节点是叶子节点，或者仅有一个子节点
            Node child = null;
            if (p.left != null) { //要删除的p节点只有一个左子节点
                child = p.left;
            }else {
                child = p.right; //要删除的p节点只有一个右子节点
            }

            if (pp == null) { //说明要删除的就是根节点
                root = child;
            }
            if (pp.left == p) { //如果p节点在父节点pp的左边
                pp.left = child;
            }else {
                pp.right = child; //p节点在父节点pp的右边
            }
        }


    }

    /*
     三、平衡二叉树
        二叉树的查找、插入、删除性能，跟树的高度成正比
        为了解决普通二叉查找树的性能退化问题:从而衍生出平衡二叉树(因为在极端情况下，二叉树会退化为链表，时间复杂度会退化为O(n))

        平衡二叉查找树: 比如AVL树
        定义: 任意一个节点的左右子树的高度相差不能大于1

        近似平衡二叉查找树: 比如红黑树
        树的高度近似log2n

        各个操作的性能: 完全二叉树 > 平衡二叉树 > 近似平衡二叉树
        维护平衡的成本: 完全二叉树 > 平衡二叉树 > 近似平衡二叉树
        完全二叉树虽然操作效率最高，但是每次插入或者删除节点时都需要动态调整使树保持矮胖，维护成本很高，因此我们做一定的
        妥协，
    */


}
