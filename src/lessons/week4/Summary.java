package lessons.week4;

/**
 * @version 1.0
 * @Description:
 * @author: bingyu
 * @date: 2022/5/16
 */
public class Summary {

    /*
       1.什么是分治?什么是递归?
         (1).分治是一种思想，分而治之。具体到算法方面，就是将原问题划分成多个规模更小且结构与原问题相同的子问题，先解决这些子问题，
             然后再合并其结果，就得到原问题的解。
         (2).递归是一种编程技巧:一个函数自己调用自己。
             递归也具有结构相同，规模不同的特点。所以，涉及到用分治思想解决问题，比较适合用递归来实现。
       2.递归函数与函数调用栈
         函数调用栈---函数调用栈里包含栈帧，每个栈帧表示方法的执行
           栈帧包含:1.参数 2.局部变量 3.返回地址(即调用该方法的位置)
     */

    /*
     3.堆栈溢出、重复计算
     (1)堆栈溢出如何解决?
      a.限制递归深度
      b.改用非递归实现
     (2)重复计算问题如何解决?(当在递归中经常会出现重复计算，如果数据的规模很大，那么会出现大量的重复计算，严重影响性能)
        a.备忘录(就是用一个变量来记录之前递归计算过的结果，注意使用该方法时必须要在递归函数外面套一层才行，需要自己自定义个方法再调用题目给的目标方法！)
        b.考虑是否可以用DP解决(回溯)
    */

    //TODO:例子
    public int f(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        return f(n-1) + f(n-2);
    }

    //TODO:用备忘录的思想解决重复计算
    private int[] mem; //创建一个数组用来记录递归的结果
    public int f_r(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        if (mem[n] !=0) return mem[n];
        mem[n] = f_r(n-1) + f_r(n-2);
        return mem[n];
    }
    /*
                                   f(5)
                                 /      \
                                /        \
                               /          \
                             f(4)         f(3)---重复计算
                            /   \          / \
                           /     \        /   \
               重复计算----f(3)   f(2)    f(2)  f(1)
                         /  \
                        /    \
                      f(2)   f(2)
     */


    /*
      4.如何用递归来解决问题
        --怎么发现这个问题可以用递归来做?
        (1).规模更小的问题，跟规模更大点的问题，解决思路相同、仅规模不同。
        (2).利用子问题的解可以组合得到原问题的解。
        (3).存在最小子问题，可以直接返回结果(存在递归终止条件)

        --递归的正确编写姿势是什么样的?
        我们可以假设子问题B、C已经解决，在此基础上思考如何解决原问题A。
        基于此，找递推公式+终止条件，然后翻译成代码
        注意:千万不要试图想清楚整个递归的执行过程，实际上是进入了一种思维误区！
    */

    /*
     5.递归时间、空间复杂度分析
       (1).递推公式:只适用于某些情况，大部分并不适合递归代码的时间、空间复杂度分析
       (2).递归树:比较普适，推荐使用该方法分析
    */
}
