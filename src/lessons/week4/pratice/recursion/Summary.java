package lessons.week4.pratice.recursion;

/**
 * @version 1.0
 * @Description:
 * @author: bingyu
 * @date: 2022/5/16
 */
public class Summary {

    /*
       1.什么是分治?什么是递归?
         (1).分治是一种思想，分而治之。具体到算法方面，就是将原问题划分成多个规模更小且结构与原问题相同的子问题，先解决这些子问题，
             然后再合并其结果，就得到原问题的解。
         (2).递归是一种编程技巧:一个函数自己调用自己。
             递归也具有结构相同，规模不同的特点。所以，涉及到用分治思想解决问题，比较适合用递归来实现。
       2.递归函数与函数调用栈
         函数调用栈---函数调用栈里包含栈帧，每个栈帧表示方法的执行
           栈帧包含:1.参数 2.局部变量 3.返回地址(即调用该方法的位置)
     */

    /*
     3.堆栈溢出、重复计算
     (1)堆栈溢出如何解决?
      a.限制递归深度
      b.改用非递归实现
     (2)重复计算问题如何解决?(当在递归中经常会出现重复计算，如果数据的规模很大，那么会出现大量的重复计算，严重影响性能)
        a.备忘录(就是用一个变量来记录之前递归计算过的结果，注意使用该方法时必须要在递归函数外面套一层才行，需要自己自定义个方法再调用题目给的目标方法！)
        b.考虑是否可以用DP解决(回溯)
    */

    //TODO:例子
    public int f(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        return f(n-1) + f(n-2);
    }

    //TODO:用备忘录的思想解决重复计算
    private int[] mem; //创建一个数组用来记录递归的结果
    public int f_r(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        if (mem[n] !=0) return mem[n];
        mem[n] = f_r(n-1) + f_r(n-2);
        return mem[n];
    }
    /*
                                   f(5)        2^0 = 1
                                 /      \
                                /        \
                               /          \
                             f(4)         f(3)---重复计算     2^1 = 2
                            /   \          / \
                           /     \        /   \
               重复计算----f(3)   f(2)    f(2)  f(1)   2^2 = 4
                         /  \
                        /    \
                      f(2)   f(2)
     */


    /*
      4.如何用递归来解决问题
        --怎么发现这个问题可以用递归来做?
        (1).规模更小的问题，跟规模更大点的问题，解决思路相同、仅规模不同。
        (2).利用子问题的解可以组合得到原问题的解。
        (3).存在最小子问题，可以直接返回结果(存在递归终止条件)

        --递归的正确编写姿势是什么样的?
        我们可以假设子问题B、C已经解决，在此基础上思考如何解决原问题A。
        基于此，找递推公式+终止条件，然后翻译成代码
        注意:千万不要试图想清楚整个递归的执行过程，实际上是进入了一种思维误区！
    */

    /*
     5.递归时间、空间复杂度分析
       (1).递推公式:只适用于某些情况，大部分并不适合递归代码的时间、空间复杂度分析
       (2).递归树:比较普适，推荐使用该方法分析
          使用递归树进行时间复杂度分析，假设递归树的每个节点执行时间是k，那么我们只要求出递归树中的所有节点，就能得到递归树总的
          时间复杂度，根据上面例3中的递归树，我们知道节点的数量是和树的深度有关的，假设递归树的深度是h，形成等比数列，那么节点
          总数=1*(1-2^n)/(1-2)=2^n-1，但是注意观察该例子代码的递归树不是普通的递归树，而是偏向左边的树，左边的深度大约为n，右边的
          深度大约是n/2，那么这个递归树的实际复杂度大约在2^(n/2)-1到2^n-1之间，这样它的时间复杂度就是O(a^n)，因此如果不使用备忘录，
          用递归来解决时通常都会出现时间过长的情况
    */
}
