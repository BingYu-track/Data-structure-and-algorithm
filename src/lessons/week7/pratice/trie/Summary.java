package lessons.week7.pratice.trie;

import java.util.List;

/**
 * @version 1.0
 * @Description: 字符串匹配总结
 * @author: bingyu
 * @date: 2022/12/13
 */
public class Summary {

    public static void main(String[] args) {
        String str = "habcdfcg";
        String c = "cdf";
        System.out.println(bf(str.toCharArray(),str.length(),c.toCharArray(),c.length()));

        //TODO: 1.使用trie树进行完全匹配,在一堆字符串中查找指定的字符串
        String[] strs = {"am","hello","hi", "how", "here", "her","ok","say","ell"}; //多模式子串
        Trie trie = new Trie(); //trie树
        for (String s : strs) {
            char[] chars = s.toCharArray();
            trie.insert(chars);
        }
        char[] chars = "hi".toCharArray(); //将所以字符串的集合插入字典树里后，再从字典树中查找集合中的字符串
        System.out.println("场景1:" + trie.find(chars));

        //TODO: 2.场景2应用，在主串里查找多个模式子串，并得到每个模式串在主串所在位置
        String mainStr = "abdhellosayhiok";
        System.out.println("场景2:" );
        trie.match(mainStr.toCharArray());

        //TODO: 3.前缀匹配
        List<String> strings = trie.prefixMatch("he".toCharArray());
        System.out.println("场景3: " + strings);
    }

    //一、单模式串匹配算法，在主串中查找一个模式串(例如:给定一个主串"habcdfcg"中查找"cdf"这个模式串所在的位置)
    /*

      1.BF算法
         --暴力匹配算法、朴素字符串匹配算法
         如果模式串长度为m,主串长度为n，那么在主串中就会有n-m+1个长度为m的子串,然后我们只需要暴力地对比这n-m+1
         个子串与模式串,就可以找出主串与模式串匹配的子串。
         例如：主串是 b a d d e f，子串是abc
         i=0
         b a d d e f
         a b c

         i=1
         b a d d e f
           a b c

         i=2
         b a d d e f
             a b c

         i=3
         b a d d e f
               a b c

        TODO: 可以这样理解n-m+1，我们子串从第一个字符出发，到子串的最后一个字符和主串的最后一个字符重叠结束，这样子串的第一个字符经过主串的字符个数
         就是n-m+1个，代表有n-m+1个子串，以上面为例就是子串abc的第一个字符a在主串b a d d e f中经过了badd这四个字符结束，因此此时子串最后一个字符
         c刚好和主串最后一个字符重叠，再往后长度就主串就没有元素了，因此模式串长度为m,主串长度为n，那么在主串中就会有n-m+1个长度为m的子串
     */
    /**
     * BF算法--返回第一个匹配的起始下标位置
     * @param main 主串
     * @param n 主串长度
     * @param b 子串
     * @param m 子串长度
     * 时间复杂度分析:外层循环执行了n-m+1次，而第二层循环不一定会执行m次，因此该算法时间复杂度取决于子串的长度
     *  最好时间复杂度: 最好情况就是进入第二层循环就break了，因此是O(n-m+1)，如果n大于m很多就是O(n)，因为外层循环会执行很多次，
     *               如果n和m相差不远就是常量级O(1)，最好情况就是外层循环只需要执行1次
     *  最坏时间复杂度: 最坏情况每次进入第二层循环都执行了m次，因此执行了(n-m+1)*m次，化简的O(n*m)
     */
      public static int bf(char main[],int n,char b[],int m) {
          for (int i = 0;i <= n-m;i++) { //从下标0开始，i表示主串中的位置下标
              int j = 0; //j用来记录当前子串里的下标
              while (j<m) { //子串下标没超过当前子串长度
                  if (main[i+j] != b[j]) { //TODO 主串下标和子串下标元素进行比较，看是否相等，通过控制j的自增使主串下标和子串下标同时移动并进行比较
                      break;
                  }
                  j++;
              }
              if (j == m) { //执行到这里说明子串里的所有字符都已经比较完毕，且均相同，此时i就是第一个匹配的模式串在主串的位置下标
                  return i;
              }
          }
          return -1;
      }


    /*
      2.RK算法(Rabin-Karp算法)
       原理:
       (1).通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较。如果某个子串的哈希值与模式串的哈希值相等,
       那么就说明这个子串和模式串匹配了。

       (2).对比hash值很简单，因此单纯对比hash值，是O(n-m+1)的时间复杂度。但是看计算每个子串的hash值是很耗费时间的，每次计算需要扫描
       m个字符，因此如何降低计算Hash的时间复杂度呢？
       解决方法: RK算法有个hash函数可以通过前一个子串的hash值,推导出后面子串的hash值，因为前一个子串A和后面一个子串B的字符是有重叠的，我们只需要
       计算出子串A的hash值后，就很容易计算出后面子串B的hash值；第一个子串我们计算Hash值需要扫描m个字符，但是后面n-m个字符只需要扫描1次，总共就是
       n-m次，加起来就是需要扫`描n次，因此计算hash值的时间复杂度是o(n)
       TODO O(n-m+1) + O(n) = O(2n-m+1)约等于O(n)

       问题:如何构造hash函数?
        a.首先必须是无冲突的hash，当子串和模式串的hash比较，如果相等，就说明子串和模式串一样，如果hash值是有冲突的那么，这个子串和模式串就无法保证
          hash值相同--->子串和模式串相同了
        b.构造的hash要能通过子串的hash算出后面子串的hash
          具体思想: 因为构成字符串的字符都是26个英文字母，我们可以将子串看作一个26进制的数.
          a--->0
          b--->1
          c--->2
          .....
          z--->25
          "315" = 3*10*10 + 1*10 + 5*1
          例如: "cab" = 2*(26^2) + 0*26^1 + 1*(26^0) = 2*(26^2) + 1 类似10进制转2进制的那种套路，我们这种是相当于转为26进制
           这个m是什么? m是子串的长度,通过
          h[i]对应从下标i开始到下标i+m-1的 子串S[i,i+m-1]的hash值，相隔m个字符长度
          h[i+1]对应从下标i+1开始到下标i+m的 子串S[i+1,i+m]的hash值，相隔m个字符长度
          因此根据进制计算的公式我们可以得到以下几个等式: 26^后面是其字符所在的位数，第1个字符位数就是m-1

          从i开始长度为m的子串的hash值计算:
          h[i] = (S[i]-'a')*26^(m-1) + (S[i+1]-'a')*26^(m-2) + ...+ (S[i+m-1]-'a')*26^0
          从i+1开始长度为m的子串的hash值计算:
          h[i+1] =                     (S[i+1]-'a')*26^(m-1) + (S[i+2]-'a')*26^(m-2) + ...+ (S[i+m-1]-'a')*26^1 + (S[i+m]-'a')*26^0

          从上面的等式可以看到,将两个等式错位后得到第i+1子串的hash和第i个子串的hash之间的关系:
          h[i+1] - 26^0*(S[i+m]-'a') = (h[i] - 26^(m-1)*(S[i]-'a'))*26
          h[i+1] = (h[i] - 26^(m-1)*(S[i]-'a'))*26 + (S[i+m]-'a')
          TODO: 从h[i]可以直接计算出h[i+1]的hash值,因此该算法计算hash是常量的时间复杂度O(1)，但是要注意的是用这种算法模式串的字符集不能太大，
           并且模式串的长度不能很大，因此实际使用并不实用！
           总结:BF算法和RK算法的做法基本都是当前遇到不匹配的字符时，将模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。

      BM算法(简单了解即可)和KMP算法(简单了解即可)的核心思想是:
      在寻找某种规律，借助这种规律，当模式串和主串中的某个字符不匹配时，能够跳过一些肯定不匹配的情况，将模式串往后多滑动几位，可以这样理解，
      就是当第一个模式串的字符和主串的字符不匹配，立刻跳到主串当前字符的后m位，重新匹配即可。
      最好情况下，两种算法时间复杂度是O(n/m)
      最差情况下，有论文证明时间复杂度也是线性的O(n)，而且前面的系数很小
    */


    /*
    二、多模式串匹配算法:在主串中查找多个模式串,例如在字符串"bokacdhelloeacdworld"中查找字符串"hello","world","ok"
      Trie树(只需要知道思想原理即可，不需要知道具体处理过程)
      AC自动机(比较难，不要求掌握)

      1.Trie树其实更加适合"前缀匹配"。但凡用到多模式串匹配的地方，都是首选AC自动机，因为性能更高。多模式串匹配算法中的AC自动机和
      Trie树之间的关系，就相当与单模式串匹配算法中的BF算法和KMP算法之间的关系。

       TODO:Trie树是原理--Trie树本质，是利用字符串之间的公共前缀，将重复的前缀合并在一起
        Step1--将字符串集合构造成Trie树
             Trie树是一颗多叉树，根节点不包含字符，其他每个节点会有data存储字符串中的一个字符，并且有指针存储26个字母并指向下一个字符串的字符，
             从根节点到红色节点的一条路径表示字符串集合中的一个字符串
             举个例子：am hello hi how here her
            Trie树根节点是不包含任何字符的,先从根节点开始插入a，a下面如果没有m就插入m,次数"am"插入完成，将m字符标记为红色代表一个字符串完成；
            再从根节点开始然后插入hello，从根节点开始没有h直接插入.....，当插入末尾字符o时同样标记为红色，代表字符串"hello"插入完成
            再从根节点开始插入hi，此时根节点下面已经有h字符了，所以直接从h字符开始插入i字符即可，并标记为红色
              (  root  ) ---->根节点
                 /  \
                a     h
              /     / |\
             m     e  i o
                 / | \   \
                l  r      w
               |  |
               l  e
               |
               o
        每个节点都有个data表示当前节点存的是什么字符，同时还有个指针，它是个26个长度的数组，下标位置分表表示a~z的字母
        Step2--要查找的字符全部插入Trie树，就可以使用Trie树来进行快速查找了!

        TODO: {重点注意:Trie树不是用来从字符串里查找子串的，而是从一堆字符串集合里查找指定的字符串!如果是从字符串找多个模式子串是可以用
              Trie树的match方法}

        Trie树的应用场景
        1)字符串查找(完全匹配,就是普通查找，这里是指在多个字符串中查找指定的字符串，而不是在字符串中找其子串)--TODO 代码见Trie类的find方法
        例如，根据名字查找用户；有1万多个用户，频繁根据名字查询用户是否出现在其中。
        替代方案: 红黑树、散列表

        2)多模式串匹配 TODO: 对应Trie类的match方法
        例如，敏感词过滤系统，字符串集合包含how,hi,her,hello,so,see这几个字符串,频繁地查询某个长字符串中，
        比如abdhellosayhiok，是否包含字符串集合中的字符串
        替代方案:优先使用AC自动机

        3)前缀匹配 TODO: 对应Trie类的prefixMatch方法
        例如，自动提示功能，搜索引擎、输入法、浏览器:给定一组字符串集合，频繁在其中查询前缀为
        某个给定字符串的字符串。
        替代方案:无
    */



}
