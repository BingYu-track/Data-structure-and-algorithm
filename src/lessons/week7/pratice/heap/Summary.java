package lessons.week7.pratice.heap;

import java.util.Arrays;

/**
 * @version 1.0
 * @Description: 堆总结
 * @author: bingyu
 * @date: 2022/12/12
 */
public class Summary {


    /*
     一、堆的定义和存储
        1.堆必须是一个完全二叉树
        2.堆中的每个节点值必须大于等于(或者小于等于)其子树中每个节点的值

        如果堆中每个节点的值都大于等于子树中每个节点的值，我们把这种堆叫"大顶堆"
        如果堆中每个节点的值都小于等于子树中每个节点的值，我们把这种堆叫"小顶堆"

        堆是完全二叉树，所以，适合用数组来存储--具体存储方式是:
        TODO：
            (1).如果下标从1开始，root下标为i，则左子节点存到2i,右子节点存到2i+1; root如果是在父的左子树，则父节点下标是i/2；
                如果是在右子树，则父节点是(i-1)/2。
            (2).如果下标从0开始，root下标为i，则左子节点存到2*i+1,右子节点存到2*i+2; root如果是在父的左子树，则父节点下标是(i-1)/2
                如果是在右子树，则父节点下标也是(i-1)/2
                可以举例验证: 28,25,27,18,16,13,9,8,12

     二、堆上的操作
       1.往堆中插入数据
         将新数据插入到数组的末尾，然后执行自下而上的堆化操作。这里的堆化操作是指为了满足大顶堆或者小顶堆需要将新数据和其父节点作比较并交换到
         正确的位置，使其堆满足其特性!

       2.取堆顶元素

       3.删除堆顶元素
        把最后一个节点放到堆顶，然后利用自上而下的堆化方式让堆重新满足定义。

       4.更新元素值
         如果更新之后的值变小了，就进行: 自上而下的堆化
         如果更新之后的值变大了，就进行: 自下而上的堆化

       //TODO: 完全二叉树相关知识，节点个数为偶数，则最后一个叶子节点为左子节点；个数为奇数，则最后一个叶子节点为右子节点!
          数组编号为{0,1,2,3,4,5,6，......N-1};数组长度为N;
          1.如果 （N-1）%2==1; (或者N%2==0）说明最后一个节点是左节点: N−1=2∗i+1 ---> i=N/2−1此时N为偶数；
          2.如果 （N-1）%2==0; (或者N%2==1) 说明最后一个节点是右节点: N−1=2∗i+2 ---> i=(N-3)/2 ---> i=N/2-1 此时N为奇数
          总结:在完全二叉树中，最后一个非叶子节点的下标为 N/2 − 1;

     */


    /*大顶堆
                   28
                /      \
               25       27
              /  \     /  \
             18  16   13   9
            /  \
           8   12
     */
    public class Heap {
        private int a[]; //数组，从下标1开始存储数据
        private int n; //堆可以存储的最大数据个数
        private int count; //堆中已经存储的数据个数

        public Heap(int capacity) {
            a = new int[capacity + 1];
            n = capacity;
            count = 0;
        }

        //取堆顶元素
        public int top() {
            if (count == 0) return Integer.MIN_VALUE; //如果堆尾空，返回负数
            return a[1];
        }

        /*TODO： 向堆里插入数据，具体操作是将新的数据放入数组数据的尾部，在上述的堆数据结构看来就是放在16的左边，那么已知新的数据下标i，
           就可以得到16的下标i/2,再比较大小，如果大于父节点，就与父节点交换位置，否则当前位置就是正确的位置!
         */
        public void insert(int data) {
            if (count >= n) return; //堆满了
            count++;
            a[count] = data;
            int i = count;
            while (i/2 > 0 && a[i] > a[i/2]) { //自下往上堆化(这里我们的堆都是大顶堆)
                swap(a, i, i/2); //swap()函数作为:交换下标为1和i/2的两个元素
                i = i/2;
            }
        }

        //删除堆顶元素
        public void removeTop() {
            if (count == 0) return;
            a[1] = a[count]; //将最后一个元素替换到堆顶元素位置
            count--;
            heapify(a,count,1); //自上而下堆化
        }

        /**
         * 注意删除堆顶元素自上而下进行堆化时，不能简单比较左右节点大小然后交换位置，这样完全二叉树是会产生空洞，变成非完全二叉树，也就不再是堆了
         * 正确删除堆顶元素的堆化操作是: 将最后一个元素移动到堆顶元素的位置，再进行自上而下的堆化，交换左右较大的子节点即可，这样就不会出现空洞了!
         * @param a 数组堆
         * @param n 堆的大小
         * @param i 当前处理的节点位置
         */
        private void heapify(int[] a, int n, int i) { //自上而下堆化
            while (true) {
                int maxPos = i; //这里表示后面将要交换的节点下标位置
                if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2; //不数组越界，且当前节点比左子节点小，记录其下标位置，后面可能需要互换
                if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1; //不数组越界，且当前节点的左子节点比右子节点小，则记录右子节点的下标位置
                if (maxPos == i) break;
                swap(a,i,maxPos); //交换位置
                i = maxPos; //更新新的下标位置
            }
        }

        private void swap(int a[],int i,int j) {
            int tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }

        /** 待实现
         * 更新堆中指定的元素
         * @param a 堆数组
         * @param n 堆中元素的个数
         * @param element 新的元素值
         * @param targetIndex 需要被更新元素的下标地址
         */
        public void update(int[] a, int n, int element ,int targetIndex) {

        }



    }


    /*
     三、 堆排序
       堆排序包含两个大的步骤:
        1.首先需要进行初始化建堆，将数组中的数据原地组织成一个堆。此时时间复杂度为O(n)
          方法(1).从前往后处理每个元素，对每个元素执行自下而上的堆化(类似堆的插入操作) 时间复杂度: O(nlogn)
              TODO: 这里自下而上堆化，是指每次当前节点和其父节点进行比较然后交换
               时间复杂度分析，假设完全二叉树的节点个数为N，当前节点所在的深度是h,那么该节点需要和它上面所有的父节点进行比较，即需要比较h-1次，高度h=log2N；
               ，因为下标从0~(N/2-1)都是非叶子节点，N/2~N-1都是叶子节点，因此叶子节点数目为N-（N/2） + 1 = N/2+1，则光叶子节点就比较了
               (N/2+1)*log2N,明显数据复杂度是O(nlogn)!
          方法(2).从后往前处理每个元素，对每个元素执行自上而下的堆化(类似堆的删除操作) 时间复杂度:O(n)
              TODO: 这里自上而下堆化，是指每次当前节点与其子节点进行比较然后交换，因此叶子节点不需要进行处理，因为没有子节点，因此直接从
                最后一个非叶子节点开始，N/2-1。

            总结:为什么"从前往后处理，自下而上"要比"从后往前处理，自上而下"的要慢一个数量级呢?
              TODO: 因为“从前往后处理，自下而上”开始长度是最短的，节点个数也是最少的，随着执行到后面，节点个数越来越多，长度也越来越长。
               而"从后往前处理，自上而下"，则是从节点个数最多的一层开始，此时长度也是最短，随着不断执行，层数越不断向上，虽然比较的长度越来
               越长，但是节点的个数也是越来越少，因此"从后往前处理，自上而下"的处理消耗的时间肯定是比"从前往后处理，自下而上"要少很多!
            具体证明: S = h*2^0 + (h-1)*2^1 + (h-2)*2^2 + .... + 1*2^(h-1)    S为比较的次数
                   2S =    2h + (h-1)*2^2  + (h-2)*2^3 + .... + 2^h
                 然后将其错开用2S减去S
                 2S-S = -h + 2h-(h-1)*2 +  (h-1)*2^2 - (h-2)*2^2 + (h-2)*2^3-(h-3)*2^3 + ....+ 2*2^(h-1)- 2^(h-1)  + 2^h
                    S = -h + 2 + 2^2 + 2^3 + .... + 2^(h-1) + 2^h    -----这里明显是一个等比数列
                    S = 2*(1-2^h)/1-2 - h
                 因为h = log2N，因此S = 2*(1-2^log2N)/-1 - log2N
                    S=2*(1-N)/-1 - h => S=2*(N-1) - h = 2N - 2 - log2N
                  因此"从后往前处理，自上而下"的堆化处理时间复杂度是O(n)

        2.排序，基于堆排序数据。
          2.1 将堆顶元素与最后一个元素交换。最大元素就放到了下标为n的位置，堆大小减1
          2.2 交换之后的堆顶元素，自上而下进行堆化，重新建成堆。
          一直重复这两个步骤，直到最后堆中只剩下一个元素，排序工作就完成了。
               1 ----->2^0 * h
             /   \
            8     5----->2^1 * h-1
           / \   / \
         4   10 2   6---->2^2 * h-2
        / \  / \
       1  1 1   9   ------>2^(h-1) * 1

       首先将其初始化为堆得到:[10,9,6,4,8,2,5,1,1,1,1]，时间复杂度为O(n)，然后根节点和最后一个节点进行交换得到[1,9,6,4,8,2,5,1,1,1,10]，
       排除掉最后一个节点,堆节点个数就为N-1，此时根节点是不满足大顶堆条件的，此外其它节点都是满足的，因此需要从根节点开始自上而下进行堆化，即根节点需要和
       它下面的深度个数的节点进行比较，因此时间复杂度为log2(N-1)，同理log2(N-2)、log2(N-3).......
       总比较次数为；
        log2(N-1) + log2(N-2) + log2(N-3) +...+ log2(1) = log2((N-1) * (N-2) * (N-3) *..... * (1))
        (N-1) * (N-2) * (N-3) *..... * 2 * 1 = log2(N-1)!

        需要知道这样一个小知识(N/2)^(N/2) <=N!<=N^N,因此log2(N-1/2)^(N-1/2))<=log2(N-1)!<=log2(N-1)^(N-1)
        得到(N-1)/2log2(N-1)/2 <= log2(N-1)!<=(N-1)log2(N-1),因此排序过程中时间复杂度为O(nlogn)

                1
              /   \
             9     6
            / \   / \
          4    8 2   5
         / \  / \
        1  1 1  10

      TODO: 总结--初始建堆是O(n)，排序过程中是O(nlogn)，因此整个堆排序的时间复杂度应该是O(nlogn)
           堆排序是原地排序；
           堆排序不是稳定排序算法，因为堆顶元素和最后一个元素进行交换了，会导致不稳定
           堆排序空间复杂度为O(1)

       堆常见习题:
        1.优先级队列 (实际上优先级队列就是一个大顶推或者小顶堆，java中优先级队列其实都是由大顶堆或者小顶堆实现的)
        2.TOP K问题
          第K大的元素--指从小到大排序后，从右边算起的第k个元素
          第K小的元素--指从小到大排序后，从左边算起的第k个元素
          (1).针对静态数据(即题目给的数据不变，此时只包含查询TOPK操作，一般有多种解法)
              方法一就是先排序，然后取数组中的第k个元素
              方法二就是利用快排算法的思想，做到O(n)
          (2).针对动态数据(只包含添加数据操作和查询TOPK操作，利用堆来解决)
              利用堆，插入O(logk)，获取O(1)
             使用堆解决TOPK问题的思路:
            TODO: 要找第k大元素，就是指找排序后的倒数第K大的元素，我们就需要维护维护一个同样大小为K的小顶堆，当有数据被添加到堆中时，
             Step1.如果堆中的数据个数小于K，我们将新数据直接插入小顶堆，将新的元素插入末尾，然后自下而上堆化；
             Step2.如果堆中的数据个数等于K，我们就拿新添加的数据与堆顶元素比较；
                       如果新添加的数据大于堆顶元素,我们就把堆顶元素删除，并将这个新添加的数据插入到堆中--比较重要
                       如果新添加的数据小于等于堆顶元素，则不对堆处理。
             不断这样进行处理直到所有数据都处理了，一遍，此时小顶堆里的根节点就是我们要找的第k大的元素(因为小顶堆堆顶是其中最小的元素，遇到比堆顶
              大的，删除堆顶并插入新的元素，不断操作堆里存的就是前K大的元素了!)
             也就是说，小顶堆中一直都维护当前数据集合中的TOP K，每次询问当前数据的TOP K操作就变的非常高效，直接输出小顶堆中的元素即可。

        3.求中位数、百分位数 (中位数又称中值，统计学中的专有名词，是按顺序排列的一组数据中居于中间位置的数)
          如果是静态数据，只需要排个序，然后取中间的数即可；但是如果是动态数据，期间不断有新的数据插入，这样每次都需要重新
          排序，时间复杂度就很高了；因此这时就可以用堆来处理
         TODO: 具体解法--
              (1).首先我们们需要维护2个堆，一个大顶堆，一个小顶堆
              (2).假设有n个数据，放入每个堆中元素个数要接近n/2，因为n可能是偶数或者奇数；如果n是偶数，两个堆中的数据个数都是n/2；
               如果是奇数，大顶堆有n/2+1个数据，小顶堆有n/2个数据。
              (3).大顶堆中的元素要都小于等于小顶堆中的元素。
              此时，大顶堆中堆顶的元素就是中位数。
             原理: 因为小顶堆最小元素都比大顶堆最大元素大于等于，因此小顶堆里的元素一定是排序后最大的后半部分；大顶堆存的是排序后的前半部分数据，
                 而大顶堆的堆顶元素是排序后前半部分数据的最大元素，自然就是中位数了!

            问:在插入数据时，如何维护两个堆继续满足上述特性?
                如果新数据小于等于大顶堆的堆顶元素，就将这个新数据插入到大顶堆，否则就插入小顶堆。
                但是此时有可能出现两个堆中的数据个数不符合前面的约定。因此我们通过从一个堆中不停地将堆顶元素移动到另一个堆，
                通过这样的调整，让两个堆中的数据个数满足前面的约定。

     */

    public static void main(String[] args) {
        //int[] arr = {25,18,16,8,12,13,9,27,28}; //给定一组数据，让你创建一个堆,预期结果: 28,25,27,18,16,13,9,8,12
        //int[] arr = {1,5,4,5};
        int[] arr = {1,8,5,4,10,2,6,1,1,1,9};
        buildHeap1(arr);
        System.out.println(Arrays.toString(arr)); //5,5,4,1
    }

    //我们换个方法，从前往后处理，自下而上堆化
    //TODO: 需要注意的问题在于当前元素交换后，我们还要将其与新的父节点进行比较，看是否仍满足条件才行!
    /*
    执行用时：10 ms, 在所有 Java 提交中击败了7.17%的用户
    内存消耗：40.8 MB, 在所有 Java 提交中击败了84.90%的用户
    */
    private static void buildHeap1(int[] arr) { //i=2k+2
        int i = 0;
        int current = 0; //用于记录堆堆化到了什么位置
        while (i<arr.length) { //指针还在数组范围内，并且堆中的节点个数没小于总节点个数
            if (i == 0) i = current; //当节点不断向父节点比较交换直到根节点后，重新从最开始交换的位置开始
            //说明堆里已经有数据了,从后往前比较
            int num = i % 2; //判断当前i是左子节点还是右子节点
            int p1 = (i - 1) / 2; //当节点为左子节点时，父节点下标
            int p2 = (i - 2) / 2; //当节点为右子节点时，父节点下标
            int p = i; //父节点下标
            if (i!=0 && num == 0) {
                //说明当前节点为右子节点
                if (p2 >=0 && arr[p2] < arr[i]) {
                    p = p2; //父节点小于当前节点，才能交换
                    if (i-1>=0 && arr[i] < arr[i-1]) { //当前节点比左边的小，换成左节点
                        i = i - 1;
                    }
                }

            }else if (i!=0 && num==1) {
                //说明当前节点为左子节点
                if (p1 >=0 && arr[p1] < arr[i]) {
                    p = p1; //父节点小于当前节点，才能交换
                    if (i+1< arr.length && arr[i] < arr[i+1]) { //当前节点比右的小，换成右节点
                        i = i + 1;
                    }
                }
            }
            //执行到这里要么是p1，要么是p2
            if (p!=i) { //需要交换
                swap(arr, i, p);
                current = i;
                i = p; //TODO: 重点--交换元素后，再判断交换后的位置和新的父节点做比较，是否仍满足条件
                continue;
            }
            i++;
        }

    }

    //使用方法2创建大顶堆
    private static void buildHeap2(int[] arr) {
        int n = 0; //堆的节点个数
        int k = arr.length - 1;
    }


    private static void swap(int a[],int i,int j) {
        int tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    /*
             1
           /   \
          5     4
         /
        5
     */


}
