package lessons.week10.dp.example.example2;

/**
 * @version 1.0 二维背包费用问题
 * @Description: 对于一组不同重量、不同价值、不可分割的物品，选择将其中某些物品装入背包，在不超过背包最大重量限制的前提下，背包中可装入
 *  物品的总价值最大是多少? 注意这里是求最大总价值，而非最大总重量。
 * @author: bingyu
 * @date: 2023/5/5
 */
public class TwoBackPack {


    public static void main(String[] args) {
        TwoBackPack backPack = new TwoBackPack();
//        backPack.f(0,0,0);
//        System.out.println(backPack.maxV);
        int res = backPack.twoBackPack(backPack.weight, backPack.value, backPack.n, backPack.w);
        System.out.println(res);
    }

    private int maxV = Integer.MIN_VALUE; //所达物品最大总价值
    private int[] weight = {2,2,4,6,3}; //物品重量
    private int[] value = {3,4,8,9,6}; //物品价值
    private int n = 5;//物品个数
    private int w = 9; //背包承受的最大重量

    /*
                                             f(0,0,0)
                                /                                   \    ----->是否放入2
                         f(1,0,0) 不放                             f(1,2,3) 放入
                  /                     \                     /                   \  ----->是否放入2
              f(2,0,0)不放             f(2,2,4) 放入         f(2,2,3)             f(2,4,7)
              /    \                /        \            /       \            /         \  ----->是否放入4
         f(3,0,0)  f(3,4,8)     f(3,2,4)   f(3,6,12)   f(3,2,3)   f(3,6,11)  f(3,4,7)    f(3,8,15)

        我们画出多阶段决策树，看上面f(2,2,4)和f(2,2,3)，我们只需要取f(2,2,4)即选同样重量价值更大的,f(2,2,3)直接去除也不再向下遍历
     */

    /**
     * 该题无法用备忘录去重,因为我们如果用二维数组int memory[n][cw+1]来记录cv值,如果memory[i][cw]已经有值了，就直接return，这样是
     * 不对的，因为会产生不同的值，并不是说把这个值记下来，下次就不需要重复计算了，是不对的，比如前面说的f(2,2,4)和f(2,2,3)，同样的位置
     * cv值就不同！
     * 这里我们是使用普通的dfs解法
     * @param i 阶段
     * @param cw 可达的总重量
     * @param cv 可达的总价值
     */
    public void f(int i,int cw,int cv) { //调用f(0,0,0)
        if (cw == w || i == n) { //cw==w表示装满了，i==n表示物品都考察完毕
            if (cv > maxV) maxV = cv;
            return;
        }
        f(i+1,cw,cv); //选择不装第i个物品
        if (cw + weight[i] <= w) {  //可达重量加当前物品重量，没有超过最大承受重量，就将该物品放入背包
            f(i+1,cw+weight[i],cv + value[i]); //选择装第i个物品
        }
    }


    /*
      TODO: 动态规划解法

        多阶段决策模型。每个阶段决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。

        例如上面的题目(i,cw,cv)表示一个状态，第i个物品决策完之后，背包重量为cw,对应的最大价值为cv。
        用一个二维数组dp[n][w+1]，来记录每个阶段可以达到的状态。dp[i][j]表示第i个物品决策完之后，背包重量为j，对应的最大价值。

        把递归树每一层中(i,cw)重复的状态(节点)合并，只记录cv值最大的那个状态，然后基于这些状态来推导下一层(下一个阶段)的状态
        (对了，要注意，可达但是不放入物品，总价值为0时，在下面表格要与其它不可达的位置进行区分，我们用0表示可达但是价值为0，用-1表示不可达)

             0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
           |---|---|---|---|---|---|---|---|---|---|
          0| 0 |-1 | 3 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |  下标为0的物品重量为2
          -|---|---|---|---|---|---|---|---|---|---|
          1| 0 |-1 | 4 |-1 | 7 |-1 |-1 |-1 |-1 |-1 |  下标为1的物品重量为2 ，这里(1,2)坐标是存在多种选择的，可能是3也可能是4，但是取最大的价值就只填4即可！
          -|---|---|---|---|---|---|---|---|---|---|
          2| 0 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |  下标为2的物品重量为4
          -|---|---|---|---|---|---|---|---|---|---|
          3| 0 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |  下标为3的物品重量为6
          -|---|---|---|---|---|---|---|---|---|---|
          4| 0 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |-1 |  下标为4的物品重量为3
          -|---|---|---|---|---|---|---|---|---|---|
          上面填的表格就是通过上一层的状态来确定下一层的状态
     */

    /**
     * TODO: 需要重点理解!
     * @param weight 每个物品的重量列表
     * @param value 每个物品的价值列表
     * @param n 物品个数
     * @param w 背包承受的最大重量
     * @return
     */
     public int twoBackPack(int[] weight,int[] value,int n,int w) {
         int[][] dp = new int[n][w + 1]; //创建dp
         //step1: 每一个初始化为-1
         for (int i = 0;i < n;i++) {
             for (int j = 0; j <= w;j++) {
                 dp[i][j] = -1;
             }
         }

         //step2: 初始第0行
         dp[0][0] = 0;  //第0个物品不装进来
         if (weight[0] <= w) {
             dp[0][weight[0]] = value[0]; //第0个物品装进来
         }

         //TODO： step3: 就是上面填表的过程(这里是重点)
         for (int i = 1;i < n;i++) {  //从第1行开始到最后一行，表示阶段，即放或者不放第i个物品
             for (int j = 0;j <= w;j++) { //列，用来表示从0到背包承受的最大重量
                 if (dp[i-1][j] == -1) { //如果上一阶段为-1，说明不是可达的，马上跳过遍历进入下一个位置
                     continue;
                 }
                 //执行到这里说dp[i][j]是可达的位置，再比较上一行同列的位置，哪个是最大值，并把最大值赋给当前位置。
                 //dp[i-1][j]是可达的可以推导出
                 //1.不放物品，对应的就是dp[i][j]，因为重量不变嘛，其总价值等于dp[i-1][j]的价值。第一次到达这个位置时，此时dp[i][j]=-1.
                 // 取最大值后，dp[i][j]=dp[i-1][j]的价值了，即和上一阶段一样；当第2次到达该位置时，因为该位置有值了，比较与上一阶段价值谁大就放谁
                 dp[i][j] = Math.max(dp[i][j],dp[i-1][j]);

                 //2.放物品，就是在dp[i][j+weight[i]]的位置，重量就成了j+weight[i]，第一次到达这个位置时，此时dp[i][j+weight[i]]=-1，
                 // 取最大值就是dp[i-1][j] + value[i]，就是上一阶段的价值加上当前放入物品的价值
                 if (j+weight[i] <= w) { //没有超过背包最大承受重量
                     dp[i][j+weight[i]] = Math.max(dp[i][j+weight[i]],dp[i-1][j] + value[i]);
                 }
             }
         }

         //执行到这里说明全部处理完毕
         int res = -1;
         for (int j = 0; j <= w; j++) {
             if (res < dp[n-1][j]) { //从最后一行开始遍历，因为最后一行是将所有物品都放入的
                 res = dp[n-1][j];
             }
         }
        return res;
     }

}
