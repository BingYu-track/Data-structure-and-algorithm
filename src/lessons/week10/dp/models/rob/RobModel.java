package lessons.week10.dp.models.rob;

/**
 * @version 1.0
 * @Description: 打家劫舍和买卖股票模型
 * @author: bingyu
 * @date: 2023/5/30
 */
public class RobModel {


    /*
        一般动态规划问题，上一个阶段做了什么决策，不会影响到下一阶段的决策；但是打家劫舍&股票买卖这类问题，上一个阶段的决策会影响下一个
        阶段的决策，所以，每个阶段需要记录不同的决策对应的最值，而不是一个全局的最值！

        我们以下面的题目为例:
       TODO:
        你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，
        如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，
        一夜之内能够偷窃到的最高金额。
        示例 1:
        输入: [1,2,3,1]
        输出: 4
        解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
        偷窃到的最高金额 = 1 + 3 = 4 。

        示例 2:
        输入: [2,7,9,3,1]
        输出: 12
        解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
        偷窃到的最高金额 = 2 + 9 + 1 = 12 。

        提示:
        1 <= nums.length <= 100
        0 <= nums[i] <= 400

       TODO:
        分析:
        一.假如我们按照背包问题，那种一般的动态规划来解决，我们以输入: [1,2,3,1]为例
         1.先构建多阶段决策模型: n个房对应n个阶段,每个阶段决定一个房屋偷还是不偷，两种决策:偷、不偷
         2.定义状态 dp[i][j]用来表示，i表示第几个房间，j表示其金额，得到的是这样的dp表格会发现
          不能直接填其最优值，因为小偷在进行决策要不要偷dp[i]房间时要依赖于dp[i-1]房间是否偷过，单纯的按照原来那样取最大值是不行的，因此
          我们在处理dp[i]房间时还要记录上一个房间的状态，是"偷"还是"没偷"。
          下面是以[1,2,3,1]得到的所有偷的方式和金额:
             房间下标：| 0 | 1 | 2 | 3 |
              房间金额： 1   2   3   1  小偷偷到的总金额(0表示不偷，1表示偷)
                     |---|---|---|---|
                       1   0   1   0      4 (只偷第0、2房间)
                       1   0   0   1      2 (只偷第0、3房间)
                       0   1   0   1      3 (只偷第1、3房间)
                       0   1   0   0      2 (只偷第1房间)
                       0   0   1   0      3 (只偷第2房间)
                       0   0   0   1      1 (只偷第3房间)
             可以看到偷完所有房间的最大金额是4，就是只偷第0和第2个房间，因为第2个房间偷了所以第3个房间不偷，因为第2个房间不偷的最大值是2；
             如果第3个房间的金额不是1,而是3呢，即输入改成[1,2,3,3]，当我们处理第2个房间时，到第2个房间偷的最大值是4，不偷是1，那你可能
             就直接取4.但是这样就错了，因为如果你在第2个房间选择不偷，到第3个房间，最大值就是5，比4要大，前面取4的判断就是错的，因此正确
             的做法是:

             "要记录当前位置偷与不偷两个状态的最大值，然后在处理下一个房间时，再根据上一个房间的偷与不偷的最大值推导出当前房间
             偷和不偷的两个最大值，直到最后一个房间，然后直接比较最后一个房间偷、不偷两个状态哪个值大就取哪就可以了!"
             因此其状态转移方程有2个
             1.选择不偷的(因为当前房间不偷，因此上一个房间可能偷，也可能不偷)--dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1])
             2.选择偷的(因为当前房间偷了，那么上一个房间肯定是不偷)--dp[i][1] = dp[i-1][0] + nums[i]

     */


    public static void main(String[] args) {
        RobModel rob = new RobModel();
        int[] nums = {1,2,3,3};
        int res = rob.rob2(nums);
        System.out.println(res);
    }

    /*
     执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
     内存消耗：38.8 MB, 在所有 Java 提交中击败了72.70%的用户
     */
    public int rob(int[] nums) {
        int[][] dp = new int[nums.length][2]; //dp[i][0]表示在第i个房间不偷 dp[i][1]表示在第i个房间偷
        //对第0个房间进行初始化
        dp[0][0] = 0; //第0个房间不偷
        dp[0][1] = nums[0]; ///第0个房间偷
        for (int i = 1;i<dp.length;i++) {
            //选择不偷
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]);
            //选择偷
            dp[i][1] = dp[i-1][0] + nums[i];
        }
        return Math.max(dp[nums.length-1][0],dp[nums.length-1][1]);
    }

    /*
    使用一维数组解决，
    执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
    内存消耗：39 MB, 在所有 Java 提交中击败了37.97%的用户
     */
    public int rob2(int[] nums) {
        int[] dp = new int[2]; //dp[i][0]表示在第i个房间不偷 dp[i][1]表示在第i个房间偷
        //对第0个房间进行初始化
        dp[0] = 0; //第0个房间不偷
        dp[1] = nums[0]; ///第0个房间偷
        for (int i = 1;i < nums.length;i++) {
            int temp = dp[0];
            //选择不偷
            dp[0] = Math.max(dp[0],dp[1]);
            //选择偷
            dp[1] = temp + nums[i];
        }
        return Math.max(dp[0],dp[1]);
    }


}
