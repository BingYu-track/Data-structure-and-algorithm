package lessons.week10.dp.models.path;

/**
 * @version 1.0  不同的二叉搜索树， TODO：注意是二叉搜索树   重点理解!
 *                              节点的左子树只包含 小于 当前节点的数。
 *                              节点的右子树只包含 大于 当前节点的数。
 *                              所有左子树和右子树自身必须也是二叉搜索树。
 * @Description: 给你一个整数n，求恰由n个节点组成且节点值从 1 到 n 互不相同的二叉搜索树有多少种？返回满足题意的二叉搜索树的种数。
 *
 * 示例 1：
 *        1              1                   2                  3              3
 *         \              \               /    \               /              /
 *          3              2             1      3             2              1
 *         /                \                                /                \
 *        2                 3                               1                  2
 * 输入：n = 3
 * 输出：5
 *
 * 示例 2：
 *
 * 输入：n = 1
 * 输出：1
 *
 * 提示：
 * 1 <= n <= 19
 *
 * @author: bingyu
 * @date: 2023/6/12
 */
public class NumTrees {

    public static void main(String[] args) {
        NumTrees n = new NumTrees();
        int res = n.numTrees(3);
        System.out.println(res);
    }

    /*
    通过节点数，计算能构成多少种二叉树
    kp[i]表示第i个节点作为root能构成的二叉搜索树种数；dp[i]表示i个节点能构成的二叉搜索树种类；
    因为有n个节点，我们需要将每个节点作为一次根节点，来得到其树的种类，然后将其求和
    即dp[i] = kp[1] + kp[2] + kp[3] + ... + kp[i];(表示各个节点作为根节点时的二叉搜索树种类的总和)

   TODO: 问题1: 为何是 “以i为根节点的BST种类数 = 左子树BST种类数 * 右子树BST种类数”
               而不是 “以i为根节点的BST种类数 = 左子树BST种类数 + 右子树BST种类数” ?
       可以这样理解，比如1,2,3,4这4个节点以2为根节点可以得到下面这棵树，右子树有2种情况，左子树不变，这样就有2种种类的二叉搜索树了，
                  2                 2
               /   \              /   \
              1     3 ----->     1     4  (这里左子树不变，右子树有2种，整棵树就有2种)
                     \                 /
                     4                3
       如果左子树还有多种情况，那么整棵树的种类就是 左子树种类 * 右子树种类

     因此上述等式可以变为dp[i] = kp[1].left * kp[1].right + kp[2].left * kp[2].right + ... + kp[i].left * kp[i].right;
     开始以1为根节点，因为是最小的，因此左子树没有节点，剩下的全是大于1的都在右子树上；构成右子树种类的所有节点就只剩下i-1个，相当于dp[i-1]
    TODO： 用 i个节点构建 BST，除去根节点，剩i−1个节点构建左、右子树，左子树分配0个，则右子树分配到i−1 个……以此类推
            左BST        右BST
               0  ...... i-1  ----->以1为根节点
               1  ...... i-2  ----->以2为根节点
                  ......
             i-1  ...... 0    ----->以i为根节点
     因此正确的状态转移方程为: dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + .... + dp[i-1] * dp[0];
     dp[i] = ∑(dp[j] * dp[i−j−1]), 0<=j<=i−1

     那么dp[0]应该是多少呢？
    从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。
    从递归公式上来讲，dp[头结点左子树节点数量] * dp[头结点右子树节点数量] 头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1，
    否则乘法的结果就都变成0了。所以初始化dp[0] = 1

    执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
    内存消耗：38.2 MB, 在所有 Java 提交中击败了59.60%的用户
    */
    public int numTrees(int n) {
        int[] dp = new int[n+1]; //

        //初始化
        dp[0] = 1;
        for (int i= 1;i<=n;i++) { //遍历每个节点来作为根节点
            System.out.print("dp["+i+"] = ");
            for (int j = 0;j<=i-1;j++) { //遍历从1到i-1的取值，这层循环是用来将当前i作为根节点的左子树和右子树种类进行求和
                dp[i] += dp[j] * dp[i-j-1]; //dp[j]以i为根节点的左子树的BST种类，dp[i-j-1]为以i为根节点的右子树的BST种类
                System.out.print("dp["+j+"] * dp["+(i-j-1)+"] + " ); //用来打印结果，看是否符合我的预期
            }
            System.out.println();
        }
        return dp[n];
    }


}
