package lessons.week11.dp.pratice.pratice6;


import java.util.Arrays;

/**
 * @version 1.0  最长递增子序列
 * @Description: 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
 * 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
 *
 * 示例 1：
 * 输入：nums = [10,9,2,5,3,7,101,18]
 * 输出：4
 * 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
 *
 * 示例 2：
 * 输入：nums = [0,1,0,3,2,3]
 * 输出：4
 * 解释：最长递增子序列是 [0,1,2,3]，因此长度为 4 。
 *
 * 示例 3：
 * 输入：nums = [7,7,7,7,7,7,7] 这个例子看出相等的不能作为递增序列
 * 输出：1
 *
 * 提示：
 * 1 <= nums.length <= 2500
 * -10^4 <= nums[i] <= 10^4
 *
 * 进阶：
 * 你能将算法的时间复杂度降低到O(n log(n)) 吗?
 *
 * @author: bingyu
 * @date: 2023/6/30
 */
public class LengthOfLIS {

    public static void main(String[] args) {
        LengthOfLIS lis = new LengthOfLIS();
//        int[] nums = {10,9,2,5,3,7,101,18};
        int[] nums = {4,10,4,3,8,9};
        int res = lis.lengthOfLIS(nums);
        System.out.println(res);
    }

    /*
    我最开始的定义dp[i]是前i个数字构成的最长升序序列长度
    [10,9,2,5,3,7,101,18,19]
    10 dp[0] = 1    (10)
    10,9 dp[1] = 1     (10)、(9)
    10,9,2 dp[2] = 1    (10)、(9)、(2)
    10,9,2,5 dp[3] = 2  (2,5)
    10,9,2,5,3 dp[4] = 2  (2,5)
    10,9,2,5,3,7 dp[5] = 3 (2,5,7)、(2,3,7)
    10,9,2,5,3,7,101 dp[6] = 4 (2,5,7,101)、(2,3,7,101)
    10,9,2,5,3,7,101,18 dp[7] = 4 (2,5,7,101)、(2,3,7,101)、(2,5,7,18)、(2,3,7,18)
    10,9,2,5,3,7,101,18,19 dp[8] = 5 (2,5,7,18,19)、(2,3,7,18,19)
    dp[i] = dp[i-1] + nums[i]


    TODO：如果定义dp[i]是"以nums[i]结尾的数字的最长升序序列的长度"，如果是这样定义的话就不存在前面定义的那么多情况了，
       例如上面以101结尾的升序最长长度只有(2,5,7,101)、(2,3,7,101)；以18结尾的只有(2,5,7,18)、(2,3,7,18)
     以[4,5,3,4]为例
     dp[2]表示就是以3结尾的最长子序列长度，可以看到dp[2] = 1;因为这里升序只有4,5和3,4；以3结尾的升序序列只有1个3
     dp[3]表示就是以4结尾的最长子序列长度，可以看到以4结尾的升序序列只有3,4这一个，因此dp[3]=2
     分析:
     1.如果nums[i] > nums[i-1]，那么dp[i]可以在dp[i-1]的基础上增加升序长度，得到：dp[i] = dp[i-1] + 1
     2.如果nums[i] <= nums[i-1]，那么明显dp[i]没办法在dp[i-1]的基础上增加升序长度，但是nums[i]有可能存在nums[i]>nums[i-2],可不可能
       使其dp[i]在dp[i-2]的基础上增加升序长度?这样的话，nums[i]就需要和前面nums[0~i-1]都比较一次，得到所有可能的升序长度，然后再取最大值！
     3.我们把所有以nums[i]结尾的升序长度都算出来后，需要将所有这些长度取最大值，因为以nums[i]最后一个位置结尾的元素得到的最长升序序列不一定是整个序列中
     最长的升序序列，这个需要注意!
     最终的状态转移方程就是: for循环中 Math.max(dp[i], dp[0~i-1]+1); (dp[i] > dp[0~i-1])
     问: 会不会存在加上一个nums[i]<=nums[i-1]的数字导致长度会增加1？
     答: 不会，因为既然到i-1下标位置的最长长度，要想继续增加，只能是nums[i] > nums[i-1]

        执行用时：60 ms, 在所有 Java 提交中击败了56.50%的用户
        内存消耗：41.8 MB, 在所有 Java 提交中击败了48.51%的用户
   */
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        if (nums.length == 1) { //只有一个数时
            return 1;
        }
        //初始化: 因为每个数字自己就能构成一个序列，因此全部初始化为1
        Arrays.fill(dp,1);

        for (int i = 1;i<dp.length;i++) { //从1开始
            for (int j = i-1;j>=0;j--) {
                if (nums[i] > nums[j]) { //TODO: 1.nums[i]和前面的所有数字比较大小，看是否能和前面任意数字结尾的序列作为基础
                    //TODO: 2.如果nums[i]能与前面数字结尾的序列中作为基础，那么要在这些序列中取最长的那一个
                    dp[i] = Math.max(dp[i],dp[j] + 1);
                    //上面一行dp[j] + 1是nums[i]能以nums[j]数字结尾作为基础得到的升序序列长度，但是这不一定是最长的，所以还要在众多序列中取最大的那个才行！
                }
            }
            //内层循环执行完成后，表示以nums[i]数字结尾的最长升序序列长度已经求得，需要往后求nums[i+1]数字结尾的最长升序序列
        }
        //执行到这dp[i]数组里存储的就是以各个数字结尾，其升序的长度，然后我们从起中取最大值即可
        int max = Integer.MIN_VALUE;
        for (int i = 0;i<dp.length;i++) {
            max = Math.max(max,dp[i]);
        }
        return max;
    }




}
