package leetcode.dp.L091DecodeWays;

/**
 * @version 1.0  91.解码方法
 * @Description: 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
 *
 * 'A' -> "1"
 * 'B' -> "2"
 * ...
 * 'Z' -> "26"
 * 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
 * "AAJF" ，将消息分组为 (1 1 10 6)
 * "KJF" ，将消息分组为 (11 10 6)
 * 注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
 * 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
 * 题目数据保证答案肯定是一个 32 位 的整数。
 *
 * 示例 1：
 * 输入：s = "12"
 * 输出：2
 * 解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
 *
 * 示例 2：
 * 输入：s = "226"
 * 输出：3
 * 解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
 *
 * 示例 3：
 * 输入：s = "06"
 * 输出：0
 * 解释："06" 无法映射到 "F" ，因为存在前导零（"6" 和 "06" 并不等价）。
 *
 *
 * 提示：
 * 1 <= s.length <= 100
 * s 只包含数字，并且可能包含前导零。
 * @author: bingyu
 * @date: 2023/8/25
 */
public class NumDecodings {

    public static void main(String[] args) {
        NumDecodings n = new NumDecodings();
        String s = "2201";
        int res = n.numDecodings(s);
        System.out.println(res);
    }

    /*
     将数字转换成字母，首先组合的数字要在1~26之间才有效；前导0无法进行映射；要求的是解码出几种
     定义dp[i]表示在第在下标为i的数字时，解码的方法种数

     一、不包含0
     (1).后两位数小于等于26
     2: 一种
     22:  2和2、22 两种
     221: 2和2和1、2和21、22和1 三种
     2213: 2和2和1和3、2和21和3、22和1和3 、 2和2和13、22和13五种
     TODO: 可以看到2213是基于221的组合加上3这个数，有3种组合，再加上基于22加上后面2个数的2种组合 dp[i] = dp[i-1] + dp[i-2]

     (2).后两位数大于26或者存在前导0，属于非法组合
     2: 一种
     22: 2和2、22两种
     226: 2和2和6、22和6、2和26 三种
     2264: 2和2和6和4、 22和6和4、 2和26和4
     TODO: 由于后两位64数字组合不合法，相当于去除了以22为基础往后的组合，只剩下226和最后一个数字的组合 dp[i] = dp[i-1]


     二、包含0
     (1).中间存在0时，0能和前面组合成一个数，比如2201
     2: 一种
     22: 2和2、22 两种
     220: 2和20 1种  TODO: 后两位数2和0组合成了一个数，因此该数的组合只取决于上上个数构成的组合，此时dp[i]=dp[i-2]
     2201: 2和20和1  1种 TODO:到这里0和1不能组成一个数了，那么此时dp[i] = dp[i-1]


     (2).中间存在0时，但是0不能和前面组成一个小于等于26的数，比如下面的2301
     2: 一种
     23: 2和3、23两种
     230: 2和3和0、23和0、2和30 存在0和大于26的30，属于非法解因此是零种解法
     2301: 同上是0种
     TODO: 会发现无论将该数字如何分解，都会存在大于26和"前导0"或者0的数字，因此直接返回0  dp[i] = 0


      时间 1ms击败 38.65%使用 Java 的用户
      内存 39.03MB击败 12.69%使用 Java 的用户
    */
    public int numDecodings(String s) {
        s = " " + s; //字符串头部追加空格作为哨兵，追加空格既可以避免dp[i-2]越界
        int[] dp = new int[s.length()];
        char[] chars = s.toCharArray();
        //初始化
        if (chars[0]!='0') {
            dp[0] = 1; //第一个字符不是0
        }
        for (int i = 1;i<chars.length;i++) {
            int current = chars[i] - '0'; //当前数字
            int last = chars[i - 1] - '0'; //上一个数字
            int num = last * 10 + current; //组合成一个数字
            if (num <= 26 && num >= 1 && last!=0) { //能组合成一个合法的数,即没有前导0以及在1~26之间
                if (current!=0) {
                    dp[i] = dp[i-1] + dp[i-2];
                }else {
                    //current为0，并且能组成一个合法的数,失去了dp[i-1]，因为以dp[i-1]为基础作为组合的话，最后一个数就是current=0，是非法数字，因此不行
                    dp[i] = dp[i-2];
                }
            }else {
                //执行到这里说明是last和current是非法组合的数
                if (current == 0) return 0; //当前为0，并且还是非法组合数，那么直接返回0，例如上面的例子230
                else dp[i] = dp[i-1]; //current不为0，无论组合数是前导0还是大于26的组合数，都是相当于除去了dp[i-2]为基础的组合数，只剩dp[i-1]
            }
        }
        return dp[s.length()-1];
    }

}
